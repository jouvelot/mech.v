(**

  VCG_Search_Properties.v

  A formalization project for the Vickrey‑Clarke‑Groves auctions.

  Properties of the "VCG for Search" auction variant.
  - no positive transfer;
  - rationality;
  - truthfulness.

  See Tim Roughtgarden lecture notes for more details.
  (http://timroughgarden.org/f16/l/l15.pdf)

  Authors: Pierre Jouvelot(+), Lucas Sguerra(+), Emilio Gallego Arias(++).

  Date: October, 2021.

  (+) MINES ParisTech, PSL University, France
  (++) Inria, France

  Thanks for their insights to the ssreflect community, and in particular:

   - Cyril Cohen ([VCG_for_Search_truthful], [Canonical]).

  Licence: CeCILL-B.

*)

From Coq Require Import Init.Prelude Unicode.Utf8.
From mathcomp Require Import all_ssreflect.
From mathcomp Require Import fingroup.perm.

Lemma ltn_leq_mul: ∀ [m1 m2 n1 n2 : nat], 0 < m1 -> 0 < n2 -> m1 < n1 → m2 <= n2 → m1 * m2 < n1 * n2.
Proof.
move=> m1 m2 n1 n2 m10 n20 mn1 mn2.
by rewrite (@leq_ltn_trans (m1 * n2))// ?leq_pmul2l// ltn_mul2r mn1 n20.
Qed.



Lemma foo (T : finType) (t0 : T) (F : T -> nat) : 
  [arg max_(t > t0) F t] = [arg max_(t > t0) F t].
Proof. exact: erefl. Qed.

From mech.lib Require Import lib labelling mech.
From mech.vcg Require Import General_VCG VCG_Search_as_General_VCG.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Module S := VCG_Search_as_General_VCG.
Module G := VCG.

Let k' := S.k'.
Let p' := S.p'.
Let geq_bid := @geq_bid p'.

Notation lt_labelling a bs bs' l := (@lt_labelling _ _ geq_bid a bs bs' tr totr ar l).
Notation ge_labelling a bs bs' l := (@ge_labelling _ _ geq_bid a bs bs' tr totr ar l).
Notation labelling_differ_on_eq a bs bs' := 
  (@labelling_differ_on_eq _ _ geq_bid a bs bs' tr rr totr ar).
Notation is_labelling bs l := (@is_labelling _ _ geq_bid bs l).  
Notation labellingP bs := (@labellingP _ _ geq_bid bs tr totr ar). 
Notation exists_labellingW bs := (@exists_labellingW _ _ geq_bid bs tr totr ar).

(* We assume that ctrs are unique. *)

Variable uniq_cs : uniq S.cs.

(** No positive transfer. *)

Section No_positive_transfer.

(* 0 <= externality *) 
Theorem VCG_for_search_no_positive_transfer s : 'ctr_s <= 'ctr_(slot_pred s).
Proof. by rewrite S.sorted_ctrs // leq_pred. Qed.

End No_positive_transfer.

(* True value per click *)
Variable (true_value : A -> bid).

(** Rationality *)

Section Rationality.

Variable (bs : bids) (a : A). 

Definition value := true_value a * 'ctr_(slot_won bs a).

Notation bs' := (tsort bs). 
Notation i := (idxa bs a).

Variable (awins : i < S.k').

Variable (value_is_bid : bid_in bs' i (slot_won bs a) = value).

Definition utility := value - price bs a.

(* 0 <= utility *)
Theorem VCG_for_Search_rational : price bs a  <= value.
Proof.
rewrite /price -value_is_bid /externality /bid_in ifT; last by rewrite (@ltn_trans k'). 
set S := (X in X <= _). 
have : S <= \sum_(s < k | i < s) 
             tnth bs' (slot_as_agent (inord i)) * ('ctr_ (slot_pred s) - 'ctr_ s).
  apply: leq_sum => s lis.
  rewrite leq_mul2r.
  move: (@sorted_bids_sorted bs (slot_as_agent (inord i)) (slot_as_agent s)) => /= -> //.
  apply/orP; right=> //.
  by rewrite inordK ltnW.
rewrite -big_distrr/=. 
have -> : \sum_(s < k | i < s) ('ctr_ (slot_pred s) - 'ctr_ s) = 'ctr_ (inord i). 
  have -> : \sum_(s < k | i < s) ('ctr_ (slot_pred s) - 'ctr_ s) =
             \sum_(i.+1 <= s < k) (nth ctr0 S.cs s.-1 - nth ctr0 S.cs s). 
    rewrite (@big_nat_widenl _ _ _ _ 0)//= big_mkord.
    by apply: eq_bigr => s lis; last by rewrite !(@tnth_nth _ _ ctr0).
  pose F x y := (nth ctr0 S.cs x.-1 - nth ctr0 S.cs y.-1). 
  rewrite (@telescope_big _ _ _ F)/= => [|s /andP [i1s sk]].
  - rewrite ifT// /F.
    move: S.last_ctr_eq0 => /eqP.
    rewrite -(inj_eq val_inj)/= (@tnth_nth _ _ ctr0)/= => /eqP ->.
    by rewrite subn0 (@tnth_nth _ _ ctr0) inordK// (@ltn_trans k').
  - have s1k : s.-1 < k by rewrite (@leq_ltn_trans s)// leq_pred.
    rewrite addnC -sum_diff//=.
    - move: (@S.sorted_ctrs (Ordinal s1k) (Ordinal sk)) => /= /(_ (leq_pred s))/=.
      by rewrite !(@tnth_nth _ _ ctr0).
    - have ik : i < k by rewrite (@ltn_trans k').
      have is1 : i <= s.-1 by rewrite -(leq_add2r 1) !addn1 prednK ?1(@ltn_trans i.+1).
      move: (@S.sorted_ctrs (Ordinal ik) (Ordinal s1k)) => /= /(_ is1)/=.
      by rewrite !(@tnth_nth _ _ ctr0).
set bc := (X in _ <= X -> _); set bc' := (X in _ -> _ <= X) => Sbc.
have bb : bc <= bc'.
  rewrite leq_mul// eq_leq//.
  - congr (_ (tnth _ _)).
    rewrite -widen_slot_as_agent/=.
    by apply: val_inj => /=; rewrite inordK// (@ltn_trans k').
  - congr (_ (tnth _ _)).
    apply: val_inj => /=.
    rewrite inordK; last by rewrite (@ltn_trans k').
    apply: esym.
    by apply/minn_idPl; last by rewrite ltnW.
exact: (leq_trans Sbc).
Qed.

End Rationality.

Check VCG_for_Search_rational.
Print Assumptions VCG_for_Search_rational.

(** Truthfulness. *)

Section Relational.

Notation agent := 'I_n.
Notation agents := (ord_tuple n).

(* prices and winners *)

(* Type for prices, and, via rationality, prices are always less than
   bids times ctrs, i.e., p * q *)

Definition P := 'I_(p * q).

Definition O := (S.O * k.-tuple P)%type. 

Definition o0 : O := (S.o0, [tuple ord0 | s < k]).

Definition bid_geq  (l : seq bid) :=
  [rel i1 i2 : agent | let: p2 := nth ord0 l i2 in
                       let: p1 := nth ord0 l i1 in 
                       (p2 < p1) || ((p1 == p2) ==> (i1 < i2))].

Definition sort_by_bid (ps : seq bid) : n.-tuple agent := sort (bid_geq ps) agents.

Definition O_sorted_agents (bs : A -> bid) : n.-tuple agent := sort_by_bid (map bs agents).

Definition O_winners (bs :A -> bid) : k.-tuple agent := 
  [tuple nth ord0 (O_sorted_agents bs) s | s < k].

Lemma O_uniq_winners (bs : A -> bid) : uniq (O_winners bs).
Proof.  
rewrite /O_winners /=. 
set leT := (bid_geq [seq bs i | i <- enum agent]). 
set f' := nth ord0 (sort leT (enum agent)). 
rewrite (@subseq_uniq _ _ [tuple nth ord0 (O_sorted_agents bs) s | s < n])//=.
- set a := (X in subseq _ X).
  have -> : a = [seq f' (val s) | s <- enum 'I_k] ++ drop k a.
    rewrite -[in LHS](cat_take_drop k a).
    congr (_ ++ _).
    apply: (@eq_from_nth _ ord0) => [|i li]. 
    - by rewrite size_take !size_map -!enumT !size_enum_ord S.lt_k_n.
    - rewrite size_take size_map size_enum_ord S.lt_k_n in li.
      have ln : i < n by rewrite (@ltn_trans k)// S.lt_k_n.
      rewrite (@nth_map _ ord0)/= ?nth_take// ?size_enum_ord//.
      rewrite (@nth_map _ ord0) ?size_enum_ord ?nth_enum_ord//.
    by rewrite prefix_subseq.
- have -> : [seq f' (val s) | s <- enum agent] = sort leT (enum agent).
    apply: (@eq_from_nth _ ord0) => [|i li]; first by rewrite size_map size_sort.
    rewrite size_map in li.
    rewrite (@nth_map _ ord0)//. 
    congr nth => /=.
    rewrite size_enum_ord in li.
    by rewrite nth_enum_ord.
by rewrite sort_uniq enum_uniq.
Qed.

Definition is_winner o i := (slot_of i o != last_slot).

(* Mech2 = VCG for Search. *)

Definition O2 := O.

Notation A2 := bid.
Notation A2s := (n.-tuple A2).

Definition O2_winners a2s := Outcome (O_uniq_winners (tnth a2s)).

Definition O2_prices (a2s : A2s) : k.-tuple P :=
  map_tuple (inord \o price a2s) (O2_winners a2s).  

Definition O2_outcome a2s := (O2_winners a2s, O2_prices a2s).

Definition M2 : A2s -> O2 := O2_outcome.

Definition m2 : mech.type n := mech.new M2.

Definition v2 :agent -> A2 := true_value.

Definition p2 : prefs.type m2 :=
  prefs.new v2 
            (fun i (o2 : mech.O m2) => 
               if is_winner o2.1 i then 
                 v2 i * 'ctr_(slot_of i o2.1) - tnth o2.2 (slot_of i o2.1) else 0)
            v2.

(* Mech1 = General VCG *)

Definition O1 := [finType of O].

Definition G_bound (a1 : {ffun O1 -> nat}) := forall o, a1 o < p * q. (* rationality *)

Definition A1 := {f : {ffun O1 -> nat} | G_bound f}.

Notation A1s := (n.-tuple A1). 

Definition f_of_a1 := (@proj1_sig _ G_bound).

Definition S_f_of_a1 (a1 : A1) := [ffun o : S.O => f_of_a1 a1 (o, o0.2)].

Definition O1_winners (a1s : A1s) := G.oStar S.o0 (map_tuple S_f_of_a1 a1s).

Definition O1_prices (a1s : A1s) : k.-tuple P :=
  map_tuple (inord \o (G.price S.o0 ^~ (map S_f_of_a1 a1s))) (O1_winners a1s).

Lemma O1_uniq (a1s : A1s) : uniq (O1_winners a1s).
Proof. by rewrite ouniq. Qed.

Definition O1_outcome a1s := (Outcome (O1_uniq a1s), O1_prices a1s).

Definition M1 : A1s -> O1 := O1_outcome.

Definition m1 : mech.type n := mech.new M1.

Definition sig_b (i : agent) (b : A2) : {f : {ffun O1 -> nat} | G_bound f}.
Proof. 
exists [ffun o1 : O1 => b * 'ctr_(slot_of i o1.1)] => o.
by rewrite !ffunE /= ltn_mul.
Defined.

Definition v1 (i : agent) := sig_b i (true_value i).

Definition p1 : prefs.type m1 :=
  prefs.new 
    v1
    (fun i (o1 : mech.O m1) =>
       if is_winner o1.1 i then
         v2 i * 'ctr_(slot_of i o1.1) - tnth o1.2 (slot_of i o1.1) else 0)
    v1.

(* Check truthfulness. *)

Lemma G_rational i (t : A1s) : G.price S.o0 i (map S_f_of_a1 t) < p * q.
Proof. 
move: (G.bid_rational S.o0 i (map S_f_of_a1 t))
        (proj2_sig (tnth t i) (G.oStar S.o0 (map_tuple S_f_of_a1 t), o0.2)). 
rewrite tnth_map ffunE.
exact: leq_ltn_trans.
Qed.

Lemma truthful_General_VCG : truthful p1. 
Proof.
pose v := (fun i => [ffun o : S.O => v2 i * 'ctr_(slot_of i o)]).
move: (@G.truthful_General_VCG [finType of S.O] S.o0 v) => G_truth bs bs' i d av. 
have df : differ_on (map_tuple S_f_of_a1 bs) (map_tuple S_f_of_a1 bs') i.
  move=> j nji.
  rewrite /differ_on /action_on in d *.  
  by rewrite !tnth_map d.
have avf : action_on (map_tuple S_f_of_a1 bs) i = S_f_of_a1 (prefs.v p1 i).
  rewrite /action_on in av *.  
  by rewrite tnth_map av.
have tws : forall (t : A1s) (iw : is_winner (O1_winners t) i), 
    tnth (O1_winners t) (slot_of i (O1_winners t)) = i.
  move=> t iw.
  rewrite cancel_slot_inv//.
  move: iw.
  apply: contra_neqT => /negbTE niw.
  by rewrite slot_not_in.
move: (@G_truth (map S_f_of_a1 bs) (map S_f_of_a1 bs') i) => {G_truth} /(_ df).
rewrite /action_on tnth_map in av avf *.
rewrite avf /v /p1 /= !tnth_map !ffunE !tnth_ord_tuple. 
set ff := (X in S_f_of_a1 _ = X).
have -> : S_f_of_a1 (v1 i) = ff by apply: eq_ffun => o; rewrite ffunE. 
move=> /(_ erefl).
have [i't|//] := boolP (is_winner (O1_winners bs') i).  
case: ifP => [it /=|/negbFE /eqP nit//]. 
by rewrite !inordK ?G_rational// /O1_winners !tws.
by rewrite /O1_winners nit S.last_ctr_eq0/= muln0/= sub0n inordK// ?G_rational// tws.
Qed.

(* Relations *)

Hypothesis uniq_ctrs : uniq S.cs.

Definition Ra (i : agent) (a1 : A1) (a2 : A2) : Prop :=
   forall o1 : O1, (f_of_a1 a1) o1 = a2 * 'ctr_(slot_of i o1.1).

Definition Ri (i1 : n.-tuple A1) (i2 : n.-tuple A2) : Prop := 
  mech.Ri Ra i1 i2 /\ M1 i1 = M2 i2.

Definition fR (i : agent) (a2 : A2) : A1 := sig_b i a2. 

Definition fRi (bs2 : n.-tuple A2) := [tuple fR i (tnth bs2 i) | i < n].

Lemma fRP : forall i a2, Ra i (fR i a2) a2.
Proof. by move=> i b o; rewrite ffunE. Qed.

Lemma fRvP : forall i, fR i (v2 i) = v1 i.
Proof. move=> i; exact: eq_exist_curried. Qed.

Definition sig_b' (i : agent) (bs : A2s) : {f : {ffun O1 -> nat} | G_bound f}.
Proof. 
exists [ffun o1 : O1 => tnth bs i * 'ctr_(slot_of (idxa bs i) o1.1)] => o.
by rewrite !ffunE /= ltn_mul.
Defined.

Definition a1s_of bs2 := [tuple sig_b' i bs2 | i < n].

Lemma Ri12 : forall bs2 : A2s, O1_outcome (a1s_of bs2) = O2_outcome bs2. 
Proof.
move=> bs.  
have ubs : uniq bs by admit.
have weq : (O1_outcome (a1s_of bs)).1 = (O2_outcome bs).1 by admit.
congr (_, _); first by exact: weq.
apply: eq_from_tnth => i. 
rewrite !tnth_map !tnth_ord_tuple /=. 
move: weq => /= [] ->.
rewrite eq_instance_VCG_price//.
congr (inord _).
rewrite /O_winners tnth_map /O_sorted_agents tnth_ord_tuple /sort_by_bid.
congr (G.price _ _).   
- apply: eq_from_tnth => j.
  rewrite !tnth_map !tnth_ord_tuple. 
  apply: eq_ffun => o.
  rewrite ffunE /t_bidding /= /bid_in.
  set jx := (idxa _ _).
  have [io|/negbTE nin] := boolP (jx \in o).
  - move: (labellingP bs) => /forallP/(_ jx)/eqP ->.
    by rewrite uniq_labelling cancel_idxa relabel_slot.
- by rewrite slot_not_in// S.last_ctr_eq0/= muln0.
Admitted.

Lemma fRiP bs2:  Ri (fRi bs2) bs2.
Proof. 
split=> [i o|]; first by rewrite /action_on /fRi tnth_map ffunE tnth_ord_tuple.
move: (Ri12 bs2) => [Ri1 Ri2].
congr (_, _); last first. 
apply: val_inj => /=.
by rewrite Ri1.
Qed.

Lemma fRdP bs2 bs2' i (hd : differ_on bs2 bs2' i) :
  differ_on (fRi bs2) (fRi bs2') i.
Proof.
move=> j /hd ha; rewrite /action_on in ha.
by rewrite /fRi /action_on !tnth_map !tnth_ord_tuple ha.
Qed.

Lemma fRviP cs i (ha : action_on cs i = v2 i) : action_on (fRi cs) i = v1 i.
Proof. by rewrite /action_on /fRi !tnth_map !tnth_ord_tuple in ha *; rewrite ha fRvP. Qed.

Definition Ro (o1 : O1) (o2 : O2) := o1 = o2.

Lemma MR : forall (bs1 : A1s) (bs2 : A2s) (ri : Ri bs1 bs2), Ro (m1 bs1) (m2 bs2).
Proof. move=> bs1 bs2 [ri1 ri23]. exact: ri23. Qed.

Notation U1 := (@prefs.U A1 _ m1 p1).
Notation U2 := (@prefs.U A2 _ m2 p2).

Lemma RelFP : forall o1 o2, Ro o1 o2 -> U1^~o1 =1 U2^~o2.
Proof. by move=> o1 o2 o12; rewrite o12. Qed.

Lemma MP : truthful p1 -> truthful p2.
Proof. 
move=> h1 bs2 bs2' i hd1 ht1.
have ho := MR (fRiP bs2).
have ho' := MR (fRiP bs2').
have hu := RelFP ho.
have hu' := RelFP ho'.
rewrite -hu -hu'.
by apply/h1; [apply/fRdP|apply/fRviP].
Qed.

Lemma VCG_for_Search_truthful : truthful p2.
Proof. apply MP. exact: truthful_General_VCG. Qed.

End Relational.
 
Check VCG_for_Search_truthful.
Print Assumptions VCG_for_Search_truthful.

(** Truthfulness. *)

Section Relational.

Notation agent := 'I_n.

Hypothesis k'' : 0 < k'.

(* Mech2. *)

Notation A2 := bid.

Notation A2s := (n.-tuple A2).

Notation O2 := (k.-tuple agent * bids)%type. 

Definition M2 : A2s -> O2 :=
  fun a2s : A2s => let ps := [tuple tnth (tlabel a2s) (inord s)| s < k] in
                (ps, a2s).

Definition m2 : mech.type n := mech.new M2.

Definition v2 : agent -> A2 := true_value.

Definition p2 : prefs.type m2 :=
  prefs.new v2 
            (fun i (o2 : mech.O m2) => 
               let: s := slot_of i o2.1 in
               if s != last_slot then v2 i * 'ctr_s - price o2.2 i else 0)
            v2.

(* Mech1 *)

Notation O1 := O2.

Variable (o10 : O1).

Notation A1 := {ffun O1 -> nat}.

Notation A1s := (n.-tuple A1).

Definition Ra (i : agent) (a1 : A1) (a2 : A2) : Prop :=
  forall o1 : O1, let: s := slot_of i o1.1 in 
             a1 o1 = if s != last_slot then a2 * 'ctr_ s else 0.

Definition fR (i : agent) (a2 : A2) : A1 := 
  [ffun o1 : O1 =>  let: s := slot_of i o1.1 in
                   if s != last_slot then a2 * 'ctr_ s else 0].

Definition O2_of (i : agent) : O2  := 
  ([tuple if s == ord0 then i else inord (i.+1 %% n) | s < k], [tuple ord0 | i < n]).

Definition M1 : A1s -> O1 :=       
  fun a1s : A1s => let: bs := map_tuple (fun i : agent => (tnth a1s i) (O2_of i) %/ 'ctr_ ord0)
                             (ord_tuple n) in
                M2 [tuple inord (tnth bs i) | i < n].

Definition m1 : mech.type n := mech.new M1.

Definition v1 : agent -> A1 := fun i => [ffun o1 => 
                                       let: s := slot_of i o1.1 in
                                       if s != last_slot then val (v2 i) else 0].
Definition p1 : prefs.type m1 :=
  prefs.new v1
            (fun i (o1 : mech.O m1) => 
               let: s := slot_of i o1.1 in
               let: bs := map_tuple 
                            (fun i => [ffun o1 : O1 => 
                                      let: s := slot_of i o1.1 in
                                      if s != last_slot then tnth o1.2 i * 'ctr_s else 0])
                            (ord_tuple n) in
               if s != last_slot then 
                 v1 i o1 * 'ctr_s - @G.price [finType of O1] o10 i bs
               else 0)
            v1.

Lemma foo : truthful

(* Relations *)

Lemma fRP : forall i a2, Ra i (fR i a2) a2.
Proof.
move=> i a2 o1.
by rewrite ffunE.
Qed.

Definition Ro (o1 : O1) (o2 : O2) := (o1 = o2). 

Definition Ri (i1 : n.-tuple A1) (i2 : n.-tuple A2) : Prop :=
  forall i, Ra i (action_on i1 i) (action_on i2 i).

Lemma MR : forall bs1 bs2 (ri : Ri bs1 bs2), Ro (m1 bs1) (m2 bs2).
Proof.
move=> bs1 bs2.
rewrite /Ri /Ra /action_on /Ro => Ri.
rewrite /m1 /m2/= /M1 /M2.
have sii : forall i, slot_of i (O2_of i).1 = ord0.
  move=> i.
  rewrite /slot_of.
  case: tnthP => p.
  - case: sig_eqW => x px/=.
    move: px.
    rewrite tnth_map tnth_ord_tuple.
    case: ifP => [/eqP -> //|_ /eqP].
    rewrite -(inj_eq val_inj)/= inordK ?ltn_pmod// => /eqP.
    apply: contra_eq => _.
    have [// /modn_small ->/=|] := boolP (i.+1 < n); first by rewrite ltn_eqF.
    rewrite -leqNgt => ni1.
    move: (conj (ltn_ord i) ni1).
    rewrite -(@ltn_add2r 1) !addn1 => /andP. 
    rewrite andbC ltnS -eqn_leq => /eqP <-.
    rewrite modnn -lt0n.
    rewrite ltnS in ni1.
    by rewrite (@leq_trans n').
  - have // : (∃ i0 : 'I_k, i = tnth (O2_of i).1 i0). 
    by exists ord0; rewrite tnth_map tnth_ord_tuple.
congr (_, _).
- apply: eq_from_tnth => s /=.
  rewrite !tnth_map !tnth_ord_tuple.
  congr (tnth (tlabel _) _).
  apply: eq_from_tnth => i.
  rewrite !tnth_map !tnth_ord_tuple /=.
  rewrite Ri /O2_of/= sii.
  rewrite -(inj_eq val_inj)/= eq_sym -lt0n k''.
  apply: val_inj => /=.
  by rewrite inordK mulnK// S.positive_ctrs.
- apply: eq_from_tnth => s /=.
  rewrite !tnth_map !tnth_ord_tuple Ri.
  rewrite sii.
  rewrite -(inj_eq val_inj)/= eq_sym -lt0n k''.
  apply: val_inj => /=.
  by rewrite inordK mulnK// S.positive_ctrs.
Qed.

Notation U1 := (@prefs.U A1 _ m1 p1).
Notation U2 := (@prefs.U A2 _ m2 p2).

Lemma RelFP : forall o1 o2, Ro o1 o2 -> U1^~o1 =1 U2^~o2.
Proof.
move=> o1 o2 o12 i.
rewrite o12 /prefs.U /p1 /p2 ffunE.
have [nlst|//] := boolP (slot_of i o2.1 != last_slot).
congr (_ - _).
rewrite /G.price /price. 
have [|] := boolP (idxa o2.2 i < k).  
- rewrite /externality.
  by admit.
- have -> // : idxa o2.2 i < k.
    move: nlst.
    rewrite /slot_of.
    case: tnthP => [[s ps]|_]; last by rewrite -(inj_eq val_inj)/= eq_refl.
    case: sig_eqW => x px/=.  
    Search 
    by admit.

Lemma MP : truthful p1 -> truthful p2.
Proof. 
move=> h1 bs2 bs2' i hd1 ht1 /=.
have ho := MR (fRiP bs2).
have ho' := MR (fRiP bs2').
have hu := RelFP ho.
have hu' := RelFP ho'.
rewrite -hu -hu'.
by apply/h1; [apply/fRdP|apply/fRviP].
Qed.




Section TruthfulnessCases.

Lemma antimonotone_sorted (bs : bids) : 
  antimonotone (λ s : slot, tnth (tsort bs) (slot_as_agent s)).
Proof.
move=> x y lexy.  
move: (sorted_leq_nth (@transitive_geq_bid p') (@reflexive_geq_bid p')). 
rewrite !(tnth_nth bid0) /lib.geq_bid. 
apply=> //; last by rewrite inE size_tuple ltn_ord. 
- by rewrite sort_sorted //; apply: total_geq_bid.
- by rewrite inE size_tuple ltn_ord.
Qed.

Variable (bs bs' : bids) (a : A).

Variable (ubs : uniq bs) (ubs' : uniq bs').

Variable (diff : differ_on bs bs' a).

Local Definition i := idxa bs a.
Local Definition i' := idxa bs' a.

Variable (bid_true_value : action_on bs a = true_value a).

Lemma rational (awins : i < k') : price bs a <= value bs a.
Proof. 
apply: VCG_for_Search_rational => //.
by rewrite /bid_in /value -bid_true_value (labelling_spec_idxa bs).
Qed.

Definition l := tlabel bs.

Lemma l_inj : injective (tnth l).
Proof. apply: (labelling_inj bs). exact: (tlabelP bs). Qed.

Lemma cancel_a : a = tnth l i. 
Proof. by rewrite cancel_idxa. Qed.

Section iLoses.

Variable (iloses : is_winner bs a = false) (iwins' : is_winner bs' a).

Lemma lt_i'_i : i' < i.
Proof. by rewrite (@leq_trans k') // leqNgt negbT. Qed.

Let l' := lt_labelling a bs bs' l.

Lemma is_labelling_iloses : is_labelling bs' l'.
Proof. 
rewrite /l' /geq_bid.
apply: labelling_differ_on_lt.
- exact: rr.
- exact: diff.
- exact: (tlabelP bs).
- exact: lt_i'_i. 
Qed.

Lemma eq_labelling_loses : projT1 (exists_labellingW bs') = l'.
Proof.
apply: (@labelling_singleton _ _ geq_bid bs'); last by rewrite is_labelling_iloses. 
move: (exists_labellingW bs') => [lab islab]. 
exact: islab.
Qed.

Lemma leq_value_loses (s : slot) (lti's : i' < s) : 
  tnth bs a <= tnth (tsort bs') (slot_as_agent s).
Proof.
move: diff; rewrite /differ_on /action_on => d.
move: iloses; rewrite /is_winner => /negbT lek'i. 
apply: (@contraR _ _ _ lek'i).
rewrite -ltnNge.
set sa := slot_as_agent s. 
move: (labellingP bs') => /forallP /(_ sa)/eqP ->.  
rewrite eq_labelling_loses.
have nea: tnth l' sa != a. 
  apply: (@contraTneq _ _ _ _ _ lti's).
  have <- : tnth l' i' = a by rewrite tnth_mktuple /lt_index //= eq_refl cancel_idxa.
  move/(@labelling.labelling_inj _ _ geq_bid bs' l' is_labelling_iloses)/eqP.
  rewrite -(inj_eq val_inj) /= => /eqP ->.
  by rewrite ltnn.
rewrite d // -(labelling_spec_idxa bs a) -?(labelling_spec_idxa bs (tnth l' sa)).  
have -> : tnth l' sa = tnth l (agent_pred sa).
    rewrite tnth_mktuple /lt_index ifF; last by apply: gtn_eqF.
    by rewrite lti's andTb (@leq_trans k') //= ?leq_ord // leqNgt.
rewrite /l !(cancel_inv_idxa bs) => leis.
have ltis1: i < agent_pred sa.
  apply: (@contraLR _ _ _ leis).
  rewrite -!ltnNge !ltnS.
  exact: sorted_bids_sorted.
rewrite (@ltn_trans (agent_pred sa)) //= (@leq_trans s) // ?leq_ord //.
by rewrite ltn_predL (@leq_ltn_trans i').
Qed.

Lemma truthful_i_loses : value bs' a <= price bs' a. 
Proof.
rewrite /value.
move: bid_true_value => tv; rewrite /action_on in tv. 
set sw := slot_won bs' a.
have -> : val ('ctr_sw) = 'ctr_sw - 'ctr_last_slot by rewrite S.last_ctr_eq0 /= subn0.
have mini' : minn i' k' = i' by rewrite /minn ifT.
have ltsw : sw < k' by rewrite /sw /slot_won /= mini'.
have -> //:  'ctr_sw - 'ctr_last_slot = \sum_(s < k | sw < s) ('ctr_(slot_pred s) - 'ctr_s).  
  under eq_bigl=> s.
  have -> : (sw < s) = (sw < s <= (last_ord k')). by rewrite leq_ord andbT. over.
  by rewrite sum_diffs // => x y; exact: S.sorted_ctrs.
rewrite big_distrr /= /price /externality (ltn_trans _ (ltnSn k')) //. 
rewrite mini' leq_sum // => s lti's.
by rewrite -tv leq_mul // leq_value_loses.
Qed.

End iLoses.

Section iWins.

Variable (iwins : i < k') (iwins' : i' < k').

Section Overbid.

Variable lt_i'_i : i' < i. 

Let l' := lt_labelling a bs bs' l.

Lemma eq_labelling_over : projT1 (exists_labellingW bs') = l'.
Proof.
apply: labelling_singleton.
- move: (exists_labellingW bs') => [lab islab]. 
  exact: islab.
- apply: labelling_differ_on_lt. 
  - exact: rr.
  - exact: diff.
  - exact: (tlabelP bs).
  - exact: lt_i'_i.
Qed.

Lemma eq_price_bs_over : price bs a = \sum_(s < k | i < s) externality (tsort bs) s.
Proof. by rewrite /price ifT // (@ltn_trans k'). Qed.

Lemma eq_price_bs'_over : 
  price bs' a = \sum_(s < k | i' < s <= i) externality (tsort bs') s + price bs a.
Proof.
rewrite /price /externality ifT; last by rewrite (@ltn_trans k').
rewrite ifT; last by rewrite (@ltn_trans k').
rewrite (split_sum_ord lt_i'_i).  
congr (_ + _).
apply: eq_bigr => s ltis.
set j := slot_as_agent s. 
move: (labellingP bs') => /forallP /(_ j) /eqP ->. 
rewrite eq_labelling_over. 
move: (labellingP bs) => /forallP /(_ j) /eqP ->. 
rewrite uniq_labelling /l' tnth_mktuple /lt_index.
rewrite ifF; last by rewrite -(inj_eq val_inj) /=; apply: gtn_eqF; rewrite (@ltn_trans i).
rewrite ifF; last by rewrite [X in _ && X = _]leqNgt ltis /= andbF.
move: diff; rewrite /differ_on /action_on => d.
rewrite d // cancel_a. 
have: j != idxa bs a by rewrite negbT //;apply: gtn_eqF. 
apply: contraTneq => /l_inj ->.
by rewrite negbK.
Qed.

Lemma truthful_over_ind (B C : slot -> nat) (K : bid)
      (sortedC : antimonotone C)
      (sortedB : antimonotone B) m 
      (Kbound : forall m (ltimi : i' + m < i), K <= B (inord (i' + m.+1))) :
  i' + m <= i ->
  K * (C (inord i') - C (inord (i' + m))) <=
  \sum_(s < k | i' < s <= i' + m) B s * (C (ord_pred s) - C s). 
Proof.
elim: m => [_|m IH lti'm1i]; first by rewrite addn0 subnn muln0. 
have lti'mi : i' + m < i by move: lti'm1i; rewrite addnS.
have lti'mk'1 : i' + m < k'.+1 by rewrite (@leq_trans i) // (@leq_trans k') // ltnW.
have lti'm1k'1 : i' + m.+1 < k'.+1 by rewrite ltnS (@leq_trans i) // ltnW.
rewrite (@sum_diff (C (inord (i' + m)))) ?mulnDr; last first. 
rewrite sortedC // ?inordK ?leq_addl // ?leq_addr // (@ltn_trans k') //. 
rewrite sortedC // !inordK // ?leq_add2l //. 
rewrite (bigD1 (inord (i' + m.+1))) /=; last first. 
- rewrite inordK // ?leqnn ?andbT.
  by rewrite -[X in X <= _]addn0 -addn1 -addnA addn0 leq_add2l.
- rewrite big_trim_bound_P //leq_add //; last by apply: IH; rewrite ltnW.
  by rewrite ord_predK // leq_mul2r Kbound ?orbT // ltnW.
Qed.

Lemma leq_value_over m (lti'mi : i' + m < i) :
  tnth bs a <= tnth (tsort bs') (slot_as_agent (inord (i' + m.+1))).
Proof.
move: iwins iwins' => iw iw'.
rewrite /is_winner in iw iw'.
have lti'mk'1 : i' + m < k'.+1 by rewrite (@leq_trans i) // (@leq_trans k') // ltnW.
have lti'm1k'1 : i' + m.+1 < k'.+1.
  by rewrite addnS; move: (ltn_trans lti'mi iw); rewrite -(@ltn_add2r 1) !addn1.
set j := slot_as_agent (inord (i' + m.+1)).
move: (labellingP bs') => /forallP /(_ j) /eqP ->. 
rewrite eq_labelling_over tnth_mktuple /lt_index.
rewrite ifF; last by apply: gtn_eqF => /=; rewrite inordK // -[X in X <= _]addn0 ltn_add2l.
rewrite ifT; last by rewrite /j /= inordK // -[X in X < _ <= _]addn0 ltn_add2l //= addnS.
move: diff; rewrite /differ_on /action_on => d.
rewrite d // cancel_a.
move: (labellingP bs) => /forallP /(_ i) /eqP. 
move: (labellingP bs) => /forallP /(_ (ord_pred j)) /eqP. 
rewrite !uniq_labelling => <- <-.
apply: sorted_bids_sorted => /=.
rewrite inordK // addnS /= ltnW // cancel_a -/i.
have: ord_pred j != i by rewrite -(inj_eq val_inj) /= inordK // addnS /= negbT // ltn_eqF.
apply: contraTneq => /l_inj <-.
by rewrite negbK.
Qed.

Lemma truthful_over : utility bs' a <= utility bs a.
Proof.
rewrite /utility /value.
have mini : minn i k' = i by rewrite /minn ifT. 
rewrite swap_dist_subl // ?S.sorted_ctrs //= ?rational //. 
- have ->:  minn i' k' = i' by rewrite /minn ifT.
  by rewrite mini // ltnW.
- by rewrite eq_price_bs'_over leq_addl.
- move: iwins iwins' => iw iw'.
  rewrite /is_winner in iw iw'.
  rewrite eq_price_bs'_over -addnBA // subnn addn0 -bid_true_value /action_on /externality.
  have -> : val i = i' + (i - i') by rewrite subnKC //= ltnW. 
  have -> : slot_won bs a = inord (i' + (i - i')).
    apply: val_inj => /=.
    by rewrite mini inordK subnKC // ltnW.
  have -> : slot_won bs' a = inord i' by rewrite wonE. 
  apply: truthful_over_ind; last by rewrite subnKC // ltnW.
  - by rewrite /antimonotone => x y; exact: S.sorted_ctrs.
  - exact: antimonotone_sorted. 
  - exact: leq_value_over.
Qed.

End Overbid.

Section Underbid.

Variable lt_i_i' : i < i'. 

Let l' := ge_labelling a bs bs' l.

Lemma eq_labelling_under : projT1 (exists_labellingW bs') = l'. 
Proof.
apply: labelling_singleton.
move: (exists_labellingW bs') => [lab islab]; first exact: islab.
apply: labelling_differ_on_ge. 
- exact: rr.
- exact: diff.
- exact: (tlabelP bs).
- by rewrite ltnW.
Qed.

Lemma eq_price_bs'_under : price bs' a = \sum_(s < k | i' < s) externality (tsort bs) s.
Proof.
rewrite /price ifT; last by rewrite (@ltn_trans k').
apply: eq_bigr => s lti's.
rewrite /externality.
set j := slot_as_agent s.
move: (labellingP bs') => /forallP /(_ j) /eqP ->. 
rewrite eq_labelling_under. 
move: (labellingP bs) => /forallP /(_ j) /eqP ->. 
rewrite uniq_labelling tnth_mktuple /ge_index.
rewrite ifF; last by rewrite -(inj_eq val_inj) /=; apply: gtn_eqF.
rewrite ifF; last by rewrite ltnNge (ltnW lti's) //= andbF.
move: diff; rewrite /differ_on /action_on => d.
rewrite d // cancel_a. 
have: j != idxa bs a by rewrite negbT //; apply: gtn_eqF; rewrite (@ltn_trans i').
by apply: contraTneq => /l_inj ->; last by rewrite negbK.
Qed.

Lemma eq_price_bs_under : 
  price bs a = \sum_(s < k | i < s <= i') externality (tsort bs) s + price bs' a.
Proof.
rewrite /(price bs) ifT; last by rewrite (@ltn_trans k').
by rewrite (split_sum_ord lt_i_i') eq_price_bs'_under addnC.
Qed.

Lemma truthful_under_ind (B C : slot -> nat) (K : bid)
      (sortedC : antimonotone C)
      (sortedB : antimonotone B) m 
      (Kbound : forall m (ltimm' : i + m <= i'), B (inord (i + m)) <= K) :
  i + m <= i' ->
  \sum_(s < k | i < s <= i + m) B s * (C (ord_pred s) - C s) <= 
  K * (C (inord i) - C (inord (i + m))).
elim: m => [_|m IH ltim1i'].
- rewrite addn0.
  under eq_bigl => s do rewrite ltnNge andNb.
  by rewrite big_pred0_eq.
- have ltimi'1 : i + m < i'.+1.
    by rewrite (@ltn_trans i') // (@leq_trans (i + m.+1)) //  ltn_add2l. 
  have ltimk' : i + m < k' by rewrite (@leq_ltn_trans i').
  have tltim1k1 : i + m.+1 < k'.+1 by rewrite addnS.
  rewrite (@sum_diff (C (inord (i + m))) (C (inord i))) //; last first. 
  - by rewrite sortedC // ?inordK ?leq_addr // (@ltn_trans k').
  - by rewrite sortedC // !inordK // ?leq_add2l // (@ltn_trans k') // (@leq_ltn_trans i').
  - rewrite (bigD1 (inord (i + m.+1))) /=; last first.
    - rewrite inordK // ?leqnn ?andbT. 
      by rewrite -[X in X <= _]addn0 -addn1 -addnA addn0 leq_add2l.
    - rewrite big_trim_bound_P //mulnDr leq_add //; last by apply: IH.
      by rewrite ord_predK // leq_mul2r Kbound ?orbT.
Qed.

Lemma geq_value_under m (ltmi'i : i + m <= i') :
  tnth (tsort bs) (slot_as_agent (inord (i + m))) <= true_value a.
Proof.
rewrite -bid_true_value /action_on -[X in _ <= nat_of_ord X](labelling_spec_idxa bs).
apply: sorted_bids_sorted.
have -> : val (slot_as_agent (inord (i + m))) = i + m; last by exact: leq_addr.
  by rewrite /= inordK // (@leq_ltn_trans i') // (@ltn_trans k').
Qed.

Lemma truthful_under : utility bs' a <= utility bs a.
Proof.
rewrite /utility.
have mini' : minn i' k' = i' by rewrite /minn ifT. 
rewrite swap_dist_subr // ?S.sorted_ctrs //=. 
- have ->:  minn i k' = i by rewrite /minn ifT.
  by rewrite mini' // ltnW.
- by rewrite eq_price_bs_under leq_addl.
- move: iwins iwins' => iw iw'.
  rewrite /is_winner in iw iw'.
  rewrite /price -/i -/i'.
  have -> : i < k by exact: (ltn_trans iw (ltnSn k')).
  have -> : i' < k by exact: (ltn_trans iw' (ltnSn k')). 
  have eq_ends : \sum_(s < k | i' < s) externality (tsort bs') s = 
                 \sum_(s < k | i' < s) externality (tsort bs) s.
    by rewrite -eq_price_bs'_under // /price ifT //  (@ltn_trans k').
  rewrite (split_sum_ord lt_i_i') eq_ends -addnBA // subnn addn0 /externality.
  have -> : val i' = i + (i' - i) by rewrite subnKC //= ltnW.
  have -> : slot_won bs' a = inord (i + (i' - i)).
    apply: val_inj => /=.
    by rewrite mini' inordK subnKC // ltnW.
  rewrite wonE //.
  apply: truthful_under_ind; last by rewrite subnKC // ltnW. 
  - by rewrite /antimonotone => x y; exact: S.sorted_ctrs.
  - exact: antimonotone_sorted.
  - exact: geq_value_under.
Qed.
  
End Underbid.

Section Stable.

Variable eq_i_i' : i' = i.

Let l' := l.

Lemma eq_labellling_stable : projT1 (exists_labellingW bs') = l'.
Proof.
apply: (@labelling_singleton _ _ geq_bid bs').
move: (exists_labellingW bs') => [lab islab] //.
apply: (labelling_differ_on_eq a bs bs').
- exact: diff.
- exact: (tlabelP bs).
- by move: eq_i_i'; rewrite /i' leq_eqVlt => ->; rewrite eq_refl.
- exact: eq_i_i'.
Qed.

Lemma truthful_stable : utility bs' a <= utility bs a.
Proof.
rewrite /utility /value.
move: diff; rewrite /differ_on /action_on => d.
have -> : slot_won bs' a = slot_won bs a.
  apply: val_inj => /=.  
  by rewrite (_ : S.idxa bs' a = i') // (_ : S.idxa bs a = i) // -/i -/i' eq_i_i'.
rewrite leq_sub // /price !ifT 1?(@ltn_trans k') // eq_leq //.
rewrite (@eq_big _ _ _ _ _ (fun s : slot => i < s) (fun s : slot => i' < s)
                 _ (externality (tsort bs'))) => // [s|s ltis];
  first by rewrite eq_i_i'.
congr (_ * _). 
set sa := slot_as_agent s.
move: (labellingP bs') => /forallP /(_ sa) /eqP ->.
rewrite eq_labellling_stable.
move: (labellingP bs) => /forallP /(_ sa) /eqP ->.
rewrite uniq_labelling /l' d // cancel_a -/i.
apply: (@contraTneq _ _ _ _ _ ltis) => /(labelling_inj bs) => <- /=.
by rewrite ltnn.
exact: (tlabelP bs).
Qed.

End Stable.

Lemma truthful_i_wins : utility bs' a <= utility bs a.
Proof.
have [] := boolP (i' == i) => [/eqP|]; first exact: truthful_stable. 
rewrite neq_ltn => /orP [lti'i|ltii']; first exact: truthful_over.
exact: truthful_under.  
Qed.

End iWins.

Theorem truthful_VCG_for_Search_dir : utility bs' a <= utility bs a.
Proof.  
rewrite /utility. 
have [] := boolP (is_winner bs' a) => [iw'|]. 
- rewrite /is_winner in iw'.
  have [] := boolP(is_winner bs a) => iw //; first by rewrite truthful_i_wins.
  rewrite (@leq_trans 0) // leqn0 subn_eq0 truthful_i_loses //.
  exact: negbTE.
- rewrite /is_winner -leqNgt /value => lek'i'.
  by rewrite after_last_slot // muln0.
Qed.

End TruthfulnessCases.

(** Relational proof of truthfulness of m2 = VCG for Search, using m1 = General VCG. *)

Section Relational.

Notation agent := 'I_n.

Hypothesis k'' : 0 < k'.

(* Mech2. *)

Notation A2 := bid.

Notation A2s := (n.-tuple A2).

Notation O2 := (k.-tuple agent * bids)%type. 

Definition M2 : A2s -> O2 :=
  fun a2s : A2s => let ps := [tuple tnth (tlabel a2s) (inord s)| s < k] in
                (ps, a2s).

Definition m2 : mech.type n := mech.new M2.

Definition v2 : agent -> A2 := true_value.

Definition p2 : prefs.type m2 :=
  prefs.new v2 
            (fun i (o2 : mech.O m2) => 
               let: s := slot_of i o2.1 in
               if s != last_slot then v2 i * 'ctr_s - price o2.2 i else 0)
            v2.

(* Mech1 *)

Notation O1 := O2.

Variable (o10 : O1).

Notation A1 := {ffun O1 -> nat}.

Notation A1s := (n.-tuple A1).

Definition Ra (i : agent) (a1 : A1) (a2 : A2) : Prop :=
  forall o1 : O1, let: s := slot_of i o1.1 in 
             (a1 o1 = if s != last_slot then a2 * 'ctr_ s else 0) /\
               (tnth o1.2 i = a2).

Definition fR (i : agent) (a2 : A2) : A1 := 
  [ffun o1 : O1 =>  let: s := slot_of i o1.1 in
                   if s != last_slot then a2 * 'ctr_ s else 0].

Definition O2_of (i : agent) : O2  := 
  ([tuple if s == ord0 then i else inord (i.+1 %% n) | s < k], [tuple ord0 | i < n]).

Definition M1 : A1s -> O1 :=       
  fun a1s : A1s => let: bs := map_tuple (fun i : agent => (tnth a1s i) (O2_of i) %/ 'ctr_ ord0)
                             (ord_tuple n) in
                M2 [tuple inord (tnth bs i) | i < n].

Definition m1 : mech.type n := mech.new M1.

Definition v1 : agent -> A1 := fun i => [ffun o1 => 
                                       let: s := slot_of i o1.1 in
                                       if s != last_slot then val (v2 i) else 0].
Definition p1 : prefs.type m1 :=
  prefs.new v1
            (fun i (o1 : mech.O m1) => 
               let: s := slot_of i o1.1 in
               let: bs := map_tuple 
                            (fun i => [ffun o1 : O1 => 
                                      let: s := slot_of i o1.1 in
                                      if s != last_slot then tnth o1.2 i * 'ctr_s else 0])
                            (ord_tuple n) in
               if s != last_slot then 
                 v1 i o1 * 'ctr_s - @G.price [finType of O1] o10 i bs
               else 0)
            v1.

(* Relations *)

Lemma fRP : forall i a2, Ra i (fR i a2) a2.
Proof.
move=> i a2 o1.
by rewrite ffunE.
Qed.

Definition Ro (o1 : O1) (o2 : O2) := (o1 = o2). 

Definition Ri (i1 : n.-tuple A1) (i2 : n.-tuple A2) : Prop :=
  forall i, Ra i (action_on i1 i) (action_on i2 i).

Lemma MR : forall bs1 bs2 (ri : Ri bs1 bs2), Ro (m1 bs1) (m2 bs2).
Proof.
move=> bs1 bs2.
rewrite /Ri /Ra /action_on /Ro => Ri.
rewrite /m1 /m2/= /M1 /M2.
have sii : forall i, slot_of i (O2_of i).1 = ord0.
  move=> i.
  rewrite /slot_of.
  case: tnthP => p.
  - case: sig_eqW => x px/=.
    move: px.
    rewrite tnth_map tnth_ord_tuple.
    case: ifP => [/eqP -> //|_ /eqP].
    rewrite -(inj_eq val_inj)/= inordK ?ltn_pmod// => /eqP.
    apply: contra_eq => _.
    have [// /modn_small ->/=|] := boolP (i.+1 < n); first by rewrite ltn_eqF.
    rewrite -leqNgt => ni1.
    move: (conj (ltn_ord i) ni1).
    rewrite -(@ltn_add2r 1) !addn1 => /andP. 
    rewrite andbC ltnS -eqn_leq => /eqP <-.
    rewrite modnn -lt0n.
    rewrite ltnS in ni1.
    by rewrite (@leq_trans n').
  - have // : (∃ i0 : 'I_k, i = tnth (O2_of i).1 i0). 
    by exists ord0; rewrite tnth_map tnth_ord_tuple.
congr (_, _).
- apply: eq_from_tnth => s /=.
  rewrite !tnth_map !tnth_ord_tuple.
  congr (tnth (tlabel _) _).
  apply: eq_from_tnth => i.
  rewrite !tnth_map !tnth_ord_tuple /=.
  rewrite Ri /O2_of/= sii.
  rewrite -(inj_eq val_inj)/= eq_sym -lt0n k''.
  apply: val_inj => /=.
  by rewrite inordK mulnK// S.positive_ctrs.
- apply: eq_from_tnth => s /=.
  rewrite !tnth_map !tnth_ord_tuple Ri.
  rewrite sii.
  rewrite -(inj_eq val_inj)/= eq_sym -lt0n k''.
  apply: val_inj => /=.
  by rewrite inordK mulnK// S.positive_ctrs.
Qed.

Notation U1 := (@prefs.U A1 _ m1 p1).
Notation U2 := (@prefs.U A2 _ m2 p2).

Lemma RelFP : forall o1 o2, Ro o1 o2 -> U1^~o1 =1 U2^~o2.
Proof.
move=> o1 o2 o12 i.
rewrite o12 /prefs.U /p1 /p2 ffunE.
have [nlst|//] := boolP (slot_of i o2.1 != last_slot).
congr (_ - _).
rewrite /G.price /price. 
have [|] := boolP (idxa o2.2 i < k).  
- rewrite /externality.
  by admit.
- have -> // : idxa o2.2 i < k.
    move: nlst.
    rewrite /slot_of.
    case: tnthP => [[s ps]|_]; last by rewrite -(inj_eq val_inj)/= eq_refl.
    case: sig_eqW => x px/=.  
    Search 
    by admit.
  

Definition m1 := G.m o'01.

Definition v1 : agent.type n -> A1 := fun i => [ffun o'1 : O'1 => v i * 'ctr_(slot_of i o'1)].

Definition p1 := G.p o'01 v1.

End MechG1.

Definition Ra i (a1 : A1) (a : A) := forall o'1 : O'1, a1 o'1 = a * 'ctr_(slot_of i o'1).

Definition Ro (o1 : O1) (o : O) := 
  forall j, let r := tnth o j in 
       let: (ps, ws) := o1 in
       let s := slot_of j ws in
       awins r = (s != last_slot) /\ (awins r -> what r = s /\ price r = tnth ps j).

Definition fR i (a : A) : A1 := [ffun o'1 : O'1 => a * 'ctr_(slot_of i o'1)].

Lemma fRP i (a : A) : Ra i (fR i a) a.
Proof. rewrite /Ra /fR /= => o'1. by rewrite ffunE. Qed.

Lemma fRvP i : fR i (v i) = v1 i.
Proof. by []. Qed.

Variable (bs1 : n.-tuple A1) (ubs1 : uniq bs1).

Variable (bs : n.-tuple A) (ubs : uniq bs).

Variable (Ri1 : Ri Ra bs1 bs).

Lemma eq_GoStar : G.oStar o'01 bs1 = OStar.oStar bs.
Proof.
(*
move: Ri1; rewrite /Ri /Ra /action_on => R'i1.
move: (VCG_oStar_extremum bs) (oStar_extremum bs).

rewrite -(uniq_oStar_unsorted ) /VCG_oStar.
congr G.oStar.
apply: eq_from_tnth => s. 
rewrite tnth_map.
apply/ffunP => o.
rewrite ffunE tnth_ord_tuple /t_bidding /bid_in R'i1.
case: ifP => [//|/slot_not_in ->]; last by rewrite S.last_ctr_eq0 /= muln0.
Qed.
*)
Admitted. 

Lemma slot_as_idxa j :
  slot_of j (G.oStar o'01 bs1) = if idxa bs j < k then inord (idxa bs j) else last_slot.
Proof.  
apply: (@o_injective (G.oStar o'01 bs1)).
rewrite eq_GoStar.
case jin: (j \in OStar.oStar bs).
- rewrite cancel_slot_inv//. 
  case: ifP => [jk|].
  - by rewrite -OStar.slot_in_oStar ?cancel_slot_inv// -eq_GoStar.
  - by rewrite OStar.mem_oStar_inv// -eq_GoStar.
- congr tnth.
  rewrite slot_not_in// ifF//.
  move: jin; apply: contraFF => jk.
  by rewrite OStar.mem_oStar.
Qed.

Lemma idxa_wins_as_slot j :
  (idxa bs j < k') = (slot_of j (G.oStar o'01 bs1) != last_slot).
Proof.
rewrite slot_as_idxa //.  
have [] := boolP (idxa bs j < k') => [ltjk'|].
- rewrite ifT; last by rewrite (@ltn_trans k').
  by rewrite below_last_ord inordK // ltnW.
- rewrite -ltnNge ltnS leq_eqVlt => /orP [/eqP eqk'j|];
    last by move=> ltk'j; rewrite ifF ?eq_refl // leq_gtF.                                    
  rewrite (_ : inord (idxa bs j) = last_slot) ?if_same ?eq_refl //.
  apply: val_inj => /=.
  by rewrite inordK // -eqk'j.
Qed.

Lemma slot_won_as_slot_of j (ltijk' : idxa bs j < k') :
  slot_won bs j = slot_of j (G.oStar o'01 bs1).
Proof. by rewrite slot_as_idxa // ifT // ?wonE; last by rewrite (@ltn_trans k'). Qed.

Lemma eq_welfares_i j : 
  VCG.welfare_without_i j (instance_biddings bs) = VCG.welfare_without_i j bs1.
Proof.
rewrite /G.welfare_without_i /G.bidSum_i /G.bidSum.   
pose h := (fun o => Outcome (uniq_map_o bs o)).
pose F := (fun o => \sum_(j0 < n | j0 != j) tnth bs1 j0 o).
rewrite [in RHS](@reindex_inj _ _ _ _ h _ F) /= => [|o1 o2 h12]; last first.
  apply: val_inj => /=. 
  apply: (inj_map_tuple (labelling_inj bs (tlabelP bs))).
  by move/eqP: h12; rewrite -(inj_eq val_inj) => /eqP.
apply: eq_bigr => o _.
apply: eq_bigr => j' _.
rewrite /instance_biddings /instance_bidding /t_bidding tnth_map ffunE !tnth_ord_tuple.
move: (Ri1 j' (h o)); rewrite /action_on => ->.
rewrite /bid_in (labelling_spec_idxa bs).
case: ifP => j'ino; first by rewrite relabel_slot.  
have -> : slot_of j' (h o) = S.last_slot; last by rewrite S.last_ctr_eq0 /= muln0.
rewrite /slot_of.
case: tnthP => p //.
case: sig_eqW => s /= eqj'. 
apply: (@contraFeq _ _ _ _ _ j'ino) => _.
by apply/tnthP; exists s; rewrite eqj' tnth_map (cancel_inv_idxa bs).
Qed.

Local Lemma mem_oStar j (ltj'k : idxa bs j < k) : idxa bs j \in oStar. 
Proof.
apply/tnthP; exists (inord (idxa bs j)); rewrite tnth_map tnth_ord_tuple.
apply: val_inj => /=.
by rewrite inordK.
Qed.

(**)

Lemma eq_instance_vcg_oStar_oStar : G.oStar o0 (instance_biddings bs) = oStar.
(*
Proof.
apply: uniq_instance_oStar; first by exact: arg_maxnP.
apply: ExtremumSpec => //= o _.
have: forall o, G.bidSum (biddings bs) o <= G.bidSum (biddings bs) (OStar.oStar bs).
  move: (oStar_extremum bs) => [] omax _ p o'.
  exact: (p o' erefl).
rewrite /instance_bidSum /instance_biddings /instance_bidding. 
rewrite /biddings /bidding /t_bidding /bid_in.
pose uo := Outcome (uniq_from_idxa bs (ouniq o)).
rewrite /OStar.oStar /OStar.t_oStar /G.bidSum => /(_ uo).
under eq_bigr do rewrite tnth_map ffunE /= tnth_ord_tuple. 
under [X in _ <= X -> _]eq_bigr=> j do rewrite tnth_map ffunE /= tnth_ord_tuple. 
have eqlabiota: map_tuple (tnth (tlabel bs)) oStar = 
                [tuple tnth (tlabel bs) (slot_as_agent s)  | s < k].
  apply: eq_from_tnth => s.
  rewrite !tnth_map. 
  congr tnth.
  exact: val_inj.    
set s1 := (X in X <= _ -> _); set s2 := (X in _ -> X <= _).
have -> : s1 = s2.
  apply: eq_bigr => j _.
  rewrite tnth_map ffunE -labelling_in tnth_ord_tuple.
  case: ifP => jino //.
  by rewrite (labelling_spec_idxa bs) relabel_slot. 
set s'1 := (X in _ <= X -> _) => les'. 
rewrite (@leq_trans s'1) // eq_leq // => {les'}.
apply: eq_bigr => j _.
rewrite tnth_map ffunE labelling_in tnth_ord_tuple eqlabiota.
case: ifP => jino //.
by rewrite (labelling_spec_idxa bs) -eqlabiota relabel_slot // labelling_in eqlabiota.
Qed.
*)
Admitted.

(**)

Lemma eq_welfares j (ltjk' : idxa bs j < k') :
  VCG.welfare_with_i o0 j (instance_biddings bs) = VCG.welfare_with_i o'01 j bs1.
Proof.
rewrite /G.welfare_with_i /G.bidSum_i /G.bidSum.
rewrite (eq_bigr (fun j => tnth bs1 j (G.oStar o'01 bs1))) // => j' nej'j. 
rewrite eq_instance_vcg_oStar_oStar.  
rewrite !tnth_mktuple !ffunE /instance_biddings /instance_bidding /t_bidding. 
move: (Ri1 j' (G.oStar o'01 bs1)); rewrite /action_on => ->. 
case: ifP => j'ino.
- rewrite /bid_in (labelling_spec_idxa bs) relabel_slot //. 
  congr (_ * 'ctr_ (slot_of _ _)). 
  apply: eq_from_tnth => s /=.
  rewrite eq_GoStar // /OStar.t_oStar !tnth_map.
  congr tnth.
  exact: val_inj.
- have -> : slot_of j' (G.oStar o'01 bs1) = last_slot; last by rewrite S.last_ctr_eq0 /= muln0.
  rewrite slot_as_idxa // ifF //.
  apply: (@contraFF _ _ _ j'ino) => ltj'k. 
  exact: mem_oStar.
Qed.

Lemma MR : Ro (m1 bs1) (m bs).
Proof.
move=> j /=. 
rewrite !tnth_map /= /is_winner !tnth_ord_tuple.   
split=> [|ltjk']; first exact: idxa_wins_as_slot.
split; first exact: slot_won_as_slot_of.
rewrite eq_instance_VCG_price 1?(@ltn_trans k') //. 
by rewrite /instance_vcg_price /VCG.price eq_welfares_i eq_welfares.
exact: uniq_cs.
Qed.

Notation U := (prefs.U p).
Notation U1 := (prefs.U p1).

Lemma RelFP (o1 : O1) (o : O) : Ro o1 o -> U1^~o1 =1 U^~o. 
Proof.
move=> Ro1 j. 
rewrite /prefs.U /= /v1 (surjective_pairing o1) ffunE. 
move: (Ro1 j).  
rewrite (surjective_pairing o1). 
case: ifP => [w //= [_ /(_ w) [-> ->]] //| /= -> [] /esym /eqP -> _].
by rewrite S.last_ctr_eq0 /= muln0 sub0n.
Qed.

End Relational.

Lemma uniq_MP (p1 : prefs.type m1) (p2 : prefs.type m) : uniq_truthful p1 -> uniq_truthful p2.
(*
Proof. 
move=> h1 bs2 bs2' i hd1 ht1 /=.
have ho := MR (fRiP bs2).
have ho' := MR (fRiP bs2').
have hu := RelFP ho.
have hu' := RelFP ho'.
rewrite -hu -hu'.
by apply/h1; [apply/fRdP|apply/fRviP].
Qed.
*)
Admitted.

Variable G_uniq_truthful_General_VCG :
     ∀ (O : finType) (o0 : O) (v : VCG_Search_as_General_VCG.A → G.bidding O),
         uniq_truthful (G.p o0 v).

Theorem truthful_VCG_for_Search_rel : 
  uniq_truthful p.
Proof.  
have MR' : ∀ (bs1 : n.-tuple A1) (ubs1 : uniq bs1) (bs : n.-tuple A) (ubs : uniq bs), 
    Ri Ra bs1 bs → Ro (m1 bs1) (m bs). 
  move=> bs1 bs ri.
  exact: MR.
apply: (@uniq_MP p1).
exact: G_uniq_truthful_General_VCG.
Qed.

Section Sumn.

Lemma sumn_nconsE (s : seq nat) x0 n : sumn (ncons n x0 s) = n * x0 + sumn s.
Proof.
rewrite sumnE (big_nth x0) size_ncons /=.
elim: n => [/=|n IH]; first by rewrite !add0n sumnE [RHS](big_nth x0).
by rewrite addSn big_nat_recl // nth_ncons /= -addn1 IH addnA -mulSn addn1.
Qed.

Lemma sumn_set_nthE (s : seq nat) x0 n x :
  let x' := x + (size s <= n) * (nth x0 s n + (n - size s) * x0) in 
  sumn (set_nth x0 s n x)  = sumn s + x' - nth x0 s n.
Proof.
rewrite set_nthE !sumnE /= [in RHS]leqNgt.
case: ifP => [ltns|_] /=.
- rewrite big_cat big_cons /= mul0n addn0.  
  rewrite (big_nth x0) [X in x + X](big_nth x0) [in RHS](big_nth x0). 
  rewrite big_nat size_take size_drop ltns.  
  under eq_bigr => ? /andP [_ ltis] do rewrite nth_take //. 
  under [X in x + X]eq_bigr => ? _ do rewrite nth_drop. 
  rewrite -big_nat addnC -addnA [in RHS]addnC -addnBA //.
  - congr addn; rewrite [in RHS](@big_cat_nat _ _ _ n) //=; last by rewrite ltnW.  
    rewrite addnC -addnBA //; last by rewrite big_ltn // leq_addr.
    congr addn; rewrite -{3}(add0n n) [in RHS]big_addn.  
    rewrite subnS. 
    under eq_bigr do rewrite addSnnS addnC.
    rewrite -(@big_add1 _ _ _ _ _ predT (fun i => nth x0 s (i + n))).
    by rewrite [in RHS]big_ltn //= ?subn_gt0 // addnC -addnBA ?subnn ?addn0 ?add0n.
  - by rewrite (bigD1_seq n) ?leq_addr ?mem_index_iota /index_iota ?subn0 ?ltns ?iota_uniq.
- rewrite mul1n big_cat //= -addnBA; last by rewrite addnC -addnA leq_addr.
  congr addn; rewrite -sumnE sumn_nconsE /= addn0.
  by rewrite -addnBA ?leq_addr // [nth _ _ _ + _]addnC -addnBA // subnn addn0 addnC.
Qed.

End Sumn.

(** SP is a special case of VCG for Search.

   See Tim Roughgarden (http://timroughgarden.org/f05/ca.pdf) *)
    
Section Surplus.

(* 3 hypotheses to map VCG for Search into Second Prize. *)

Hypothesis a_single_slot_is_auctionned : S.k' = 0.

Hypothesis max_ctr_is_1 : S.q' = 1.

Lemma lt1q : 1 < q.
Proof. by rewrite /q max_ctr_is_1. Qed.
Definition ctr1 := Ordinal lt1q.
Hypothesis all_ctrs_are_1 : forall s, 'ctr_s = ctr1.

(*  A second-price Vickrey auction maximizes surplus, when bidding truthfully, i.e.,
    surplus is equal to max welfare. *)

Variable bs : bids.

Record C := new {
               val : n.-tuple nat;
               _ : sumn val = 1
             }.

Coercion val : C >-> tuple_of.

Variable (c0 : C).

Definition surplus c := \sum_(i < n) v i * tnth c i.

Definition iw := tnth (tlabel bs) ord0.       (* winning agent in SP. *)

Notation sw := (set_nth 0 [tuple 0 | i < n] iw 1).
Local Lemma szn : size sw = n.
Proof.
rewrite size_set_nth /= size_map size_enum_ord.
apply/maxn_idPr.
exact: ltn_ord.
Qed.

Definition vw := tcast szn (in_tuple sw).

Lemma isCvw : sumn vw = 1. 
Proof.
rewrite val_tcast sumn_set_nthE /sumn size_map /= !(nth_map iw) ?size_enum_ord ?ltn_ord //.
rewrite leqNgt ltn_ord /= mul0n subn0 addn0 foldrE (big_nth 0) big_nat.
under eq_bigr => i /andP [_ ltin].
  rewrite (nth_map iw). over.
  by rewrite size_map in ltin.
by rewrite big1_eq.
Qed. 
Definition cw := new isCvw.

Lemma eq_surplus : surplus cw = v iw.
Proof.
rewrite /surplus /cw /welfare /OStar.welfare /bidding /t_bidding /bid_in.
rewrite (@bigD1 _ _ _ _ iw) //= (@tnth_nth _ _ 0) val_tcast /= nth_set_nth /= eq_refl muln1.
under eq_bigr => i ltin.
  rewrite (@tnth_nth _ _ 0) val_tcast /= nth_set_nth /= ifF /=; last exact: negbTE.
  rewrite (nth_map ord0) ?muln0 ?size_enum_ord ?ltn_ord //=. 
  by over => //=.
by rewrite big1_eq addn0. 
Qed.

Lemma surplus_is_VCG_max_welfare (tv : tnth bs =1 v) :
  surplus cw = OStar.max_welfare bs.
Proof. 
rewrite eq_surplus /OStar.max_welfare /OStar.welfare /bidding /t_bidding /OStar.oStar /=.
under [RHS]eq_bigr => s _.
  rewrite ffunE /= mem_tnth /bid_in all_ctrs_are_1 muln1 /OStar.t_oStar tnth_map.
  rewrite -(labelling_spec_idxa bs) (cancel_inv_idxa bs) tnth_ord_tuple.
  over.
have -> : \sum_(s < k) tnth [tuple of sort geq_bid bs] (slot_as_agent s) =
         \sum_(0 <= s < k) tnth [tuple of sort geq_bid bs] (inord s). 
  rewrite big_mkord; apply: eq_bigr => s _ /=. 
  congr (_ (tnth _ _)).
  by apply: val_inj => /=; rewrite inordK // (@ltn_trans k) // S.lt_k_n.
rewrite /k a_single_slot_is_auctionned big_nat1 /iw. 
rewrite -(cancel_inv_idxa bs (inord 0)) (labelling_spec_idxa bs) tv /=.
congr (v (tnth _ _)).
by apply: val_inj => /=; rewrite inordK.
Qed.

End Surplus.
 
Check truthful_VCG_for_Search_dir.
Print Assumptions truthful_VCG_for_Search_dir.

Check truthful_VCG_for_Search_rel.
Print Assumptions truthful_VCG_for_Search_rel.




Lemma tnth_map_slot : forall T (t : k.-tuple A) (f : A -> T) i (it : i \in t), 
    tnth (map_tuple f t) (slot_of i t) = f i.  
Proof.
move=> T t f i it.
rewrite (@tuple_map_ord _ _ t) tnth_map. 
rewrite  cancel_slot_inv'//=.  
move: it => /tnthP [ip itp].
apply/tnthP.
exists ip.
by rewrite itp {1}(@tuple_map_ord _ _ t). 
Qed.

Lemma cancel_slot_inv' : ∀ (o : k.-tuple A) (i : A), i \in o → tnth o (slot_of i o) = i.
Proof.
move=> o i io.
rewrite /slot_of. 
case: tnthP => [[w hw //]|].
- by case: sig_eqW => s' p' /=; rewrite p'.
- move: io => /tnthP [ip itp].
  by have // : (∃ i0 : 'I_k, i = tnth o i0) by exists ip.
Qed.

